

------

## 一、 Helm 学习的框架体系

你可以按照这四个维度来构建你的知识大脑：

### 1. 核心概念（铁三角）

- **Chart**：软件包。包含了一组 K8s 资源定义的目录（就像 RPM 包）。
- **Release**：运行实例。一个 Chart 在集群里每安装一次，就产生一个 Release（比如你在 `dev` 和 `prod` 命名空间各装一个 Nginx，就是两个 Release）。
- **Repository**：仓库。存放 Chart 的地方（类似 Docker Hub 或 Yum 源）。

### 2. Helm 架构演进（避坑指南）

- **Helm v2 vs v3**：重点看 v3。v3 彻底干掉了服务端组件 **Tiller**，直接利用 `kubeconfig` 的权限。你面试时要是提到 v3 移除了 Tiller 提高了安全性，面试官会觉得你很懂。

### 3. Chart 目录结构（解剖手术）

你要对 `helm create` 出来的那个文件夹了如指掌：

- `Chart.yaml`：包的元数据（名字、版本）。
- `values.yaml`：变量文件（核心！所有环境差异都写这儿）。
- `templates/`：YAML 模板文件夹（里面全是带 `{{ .Values.xxx }}` 的占位符）。
- `charts/`：依赖的其他 Chart。

### 4. 操作指令（生存技能）

- 基础增删改查：`install`, `upgrade`, `rollback`, `uninstall`, `list`。
- 调试神技：`helm install --dry-run --debug`（模拟安装，不发给集群，只看生成的 YAML 对不对，SRE 必备）。

------

## 二、 学习内容的重难点（面试常考）

### 1. Go Template 语法（重点 & 难点）

这是 Helm 的灵魂。你需要掌握如何在 YAML 里写逻辑：

- **变量引用**：`{{ .Values.image.tag }}`
- **控制流**：`if-else` 判断，`range` 循环。
- **管道符 & 函数**：比如 `quote`, `default`, `upper`，以及最常用的 `indent`（控制缩进，YAML 的命门）。

### 2. 依赖管理（Dependency Management）

当你的项目复杂到“大包套小包”时（比如一个商城系统依赖 Redis 和 MySQL），如何管理 `Chart.yaml` 里的 `dependencies`。

### 3. 钩子机制（Hooks）

SRE 在做自动化运维时非常依赖这个。比如：在安装 App 之前，先运行一个 Job 去初始化数据库。

- 掌握 `pre-install`, `post-upgrade` 等钩子的用法。

### 4. Chart 的生命周期与版本控制

- **App Version**（程序版本） vs **Chart Version**（包版本）的区别。
- 如何实现灰度发布或一键回滚。

------

## 总结

总结一句话：Helm 就像是把杂乱的 YAML 揉成了一个带有开关（Values）的黑盒子，你的任务就是学会如何造这个盒子，以及如何优雅地按动那些开关。

## 建议

**从“改”开始**：去 **Artifact Hub** 下载一个官方的 Redis 或 Nginx Chart，拆解它的 `templates`，看大牛是怎么写模板的。

**不要只学 Helm**：Helm 是“打包”，但现在的趋势是 **GitOps**（比如 ArgoCD）。等你把 Helm 玩熟了，一定要看看怎么用 GitOps 来驱动 Helm 的自动化部署。

GitOps 的流行本质上是因为 **K8s 的声明式 API** 太强大了，而 Git 又是程序员最熟悉的工具，两者一结合，简直是“金风玉露一相逢”。





## 安全

安全体系

- 认证；
- 授权；
- 准入控制；

在Kubernetes集群中定义了两种类型的subject资源的认证用户：

User Account ，简称：UA；用户账户，指非Pod类的客户端访问API Server时使用的身份标识，是现实中的“人”
Service Account，简称：SA；服务账户，适用于集群中Pod内的进程访问API Server 时使用的身份信息，需要通过 API 来完成权限认证



查看用户组 kubeadm:cluster-admins 的权限

```powershell
kubectl get nodes
diff /etc/kubernetes/admin.conf .kube/config
grep client-certificate-data .kube/config |awk '{print $NF}'|base64 -d | openssl x509 -noout -subject
# 新版：查看role角色cluster-admin同名的clusterrolebinding，分配权限给kubeadm:cluster-admins组
kubectl get clusterrolebinding kubeadm:cluster-admins -o yaml
```

查看用户组 system:masters 的权限

一般都是创建多个用户组，将不同的用户归类用户组，以此达到用户权限管理的目的；

所有的k8s集群资源操作，其实都是通过node节点上的kubelet和master节点上的apiserver之间的通信实现，而在kubernetes的认证目录中有其专用的通信认证证书 apiserver-kubelet-client.crt，可以通过该文件来检查一下这两者之间是一个怎样的关系。

#### **案例: 创建基于 X509 客户端用户证书**

基于openssl 命令创建管理证书

```powershell
# 在 master 节点创建 test 用户证书
mkdir pki
(umask 077; openssl genrsa -out pki/test.key 4096)
# 生成证书申请 （ 加入的 ops 组只具有普通权限 ）
openssl req -new -key pki/test.key -out pki/test.csr -subj "/CN=test/O=ops"
# 使用 kubernetes-ca 颁发证书
openssl x509 -req -days 3650 -CA /etc/kubernetes/pki/ca.crt -CAkey /etc/kubernetes/pki/ca.key -CAcreateserial -in pki/test.csr -out pki/test.crt
# 测试，通过curl使用证书访问，仍是权限不足，无法访问
curl --cert pki/test.crt --key pki/test.key --key-type PEM --cacert /etc/kubernetes/pki/ca.crt https://kubeapi.wang.org:6443
# 重新生成证书申请 （ 这次加入管理员组 ）
openssl req -new -key pki/test.key -out pki/test.csr -subj "/CN=test/O=kubeadm:cluster-admins"
# 测试
curl --cert pki/test.crt --key pki/test.key --key-type PEM --cacert /etc/kubernetes/pki/ca.crt https://kubeapi.wang.org:6443
```

#### 案例：令牌 Token 认证

基于静态 token 令牌向 API Server 添加认证用户

```powershell
# 准备 Token 文件存放的独立目录
mkdir /etc/kubernetes/auth && cd /etc/kubernetes/auth
# 创建静态令牌文件并添加用户信息
echo "$(openssl rand -hex 3).$(openssl rand -hex 8),wang,1001,system:masters" > /etc/kubernetes/auth/token.csv
echo "$(openssl rand -hex 3).$(openssl rand -hex 8),test,1002,dev" >> /etc/kubernetes/auth/token.csv

# 修改 apiserver 启动加载文件 ( 最好做个备份 ) ( 不要将下面的注释复制进去 )
cp /etc/kubernetes/manifests/kube-apiserver.yaml /root/
vi /etc/kubernetes/manifests/kube-apiserver.yaml
spec:
  containers:
  - command:
    - kube-apiserver
    - --token-auth-file=/etc/kubernetes/auth/token.csv # 加一行，指定前面创建文件的路径

  volumeMounts:
  - mountPath: /etc/kubernetes/auth # 添加三行,实现数据卷的挂载配置,注意：此处是目录
    name: static-auth-token
    readOnly: true


volumes:
- hostPath: # 添加四行数据卷定义
    path: /etc/kubernetes/auth # 注意：此处是目录
    type: DirectoryOrCreate
  name: static-auth-token
```

```powershell
ps aux | grep auth
# 查看生成的 token
cat /etc/kubernetes/auth/token.csv
# 测试-1
TOKEN="1a2dab.6895748fd9e46182";
curl -k -H "Authorization: Bearer $TOKEN" https://kubeapi.wang.org:6443 
# 在 node 节点拿到 token 就可以访问 kube apiserver 了
TOKEN="1a2dab.6895748fd9e46182" 
kubectl -s "https://kubeapi.wang.org:6443" --token="$TOKEN" --certificate-authority=/etc/kubernetes/pki/ca.crt get pod -A
或者不指定认证
kubectl -s "https://kubeapi.wang.org:6443" --token="$TOKEN" --insecure-skip-tls-verify=true get pod -A
```

```powershell
# 可以看到 kebectl 是独立的二进制程序
ll /usr/bin/kubectl 
# 传到集群外的主机中
scp /usr/bin/kubectl 10.0.0.107:/usr/local/bin/
# 进入 107 这个主机；定义 token ；
TOKEN="1a2dab.6895748fd9e46182"
kubectl -s "https://10.0.0.107:6443" --token="$TOKEN" --insecure-skip-tls-verify=true get pod -A
# 由此可以看出在 k8s 集群外管理 k8s 集群的前景，并且可以延伸到在 Windows 系统通过图形界面管理 k8s 集群
# 用户一多，那么证书、token 管理就是麻烦，这就不得不说 kubeconfig 管理了！
```



### kubeconfig 管理

`admin.conf` 本质上是一个 **Kubeconfig** 文件。它就像是你进出 K8s 集群的“通关文牒”和“私钥大礼包”。`admin.conf` 拥有集群的 **最高权限（Root）**

当你把这个文件拿到从节点，执行 `kubectl` 命令时，它会读取这些信息，证明“我是谁”以及“我要去哪”，API Server 验明正身之后，就会放行。



### " 肢解 "  admin.conf  文件

- Clusters（我们要去哪儿？）

```powershell
# 这一部分定义了你要连接的目的地。
clusters:
- cluster:
    certificate-authority-data: LS0t... # 这一大段是 CA 证书
    server: https://kubeapi.wang.org:6443 # API Server 的地址
  name: kubernetes
```

> -  **server**: 这是最关键的。它告诉 `kubectl`：你要访问的集群“大门”在 `kubeapi.wang.org` 的 6443 端口。如果你在办公网环境，这个域名必须能解析到你 Master 节点的 IP，否则就会报 `getsockopt: connection refused`。
> - **certificate-authority-data**: 这是集群 CA 根证书的 Base64 编码。它的作用是**“验证服务器”**。当你访问 API Server 时，`kubectl` 会用这段数据去验证服务端给出的证书合不合法，防止你连到了黑客伪造的 API Server 上（防中间人攻击）。

- Users（我是谁？）

```powershell
# 这一部分定义了你的身份证明。
users:
- name: kubernetes-admin
  user:
    client-certificate-data: LS0t... # 客户端证书
    client-key-data: LS0t...         # 客户端私钥
```

> 1. **name**: 叫 `kubernetes-admin`。
> 2. **client-certificate-data**: 你的“身份证”。API Server 拿到这个后，会解密看里面的内容。
> 3. **重点（用户组和用户）**： 虽然你在 YAML 里看到名字叫 `kubernetes-admin`，但 K8s 内部真正识别你权限的，是**签发这个证书时写进里面的 CN (Common Name) 和 O (Organization)**。
>
> - 你可以试着用这个命令解码看看（假如你把那段 Base64 存成文件）： `echo "LS0t..." | base64 -d | openssl x509 -text -noout`
> - 你会发现这个证书的 **Subject** 里写着：`O = system:masters, CN = kubernetes-admin`。
> - **CN (kubernetes-admin)** 就是**用户名**。
> - **O (system:masters)** 就是**用户组**。
> - **为什么权限这么大？** 因为 K8s 内置了一个默认的 RBAC 策略（ClusterRoleBinding），把 `system:masters` 这个组绑定到了 `cluster-admin` 这个最高权限的角色上。所以，**只要你拿着这个证书，你就是集群的 Root。**



- Contexts（上下文：连连看）

```powershell
# 这一部分是把上面的“目的地”和“身份”关联起来。
contexts:
- context:
    cluster: kubernetes      # 使用上面定义的名为 kubernetes 的集群
    user: kubernetes-admin   # 使用上面定义的名为 kubernetes-admin 的用户
  name: kubernetes-admin@kubernetes
current-context: kubernetes-admin@kubernetes # 当前默认使用的环境
```

> - **Context** 就像是一个“拨号配置”。你可以定义很多个 Context（比如一个连生产环境，一个连测试环境），通过 `kubectl config use-context` 像切换频道一样在不同集群间切换。
> - **current-context**: 决定了当你直接敲 `kubectl get pod` 时，默认走哪个配置。





```powershell
# 生成 kubeconfig 管理文件
kubectl config set-cluster myk8s --server=https://10.0.0.101:6443 --certificate-authority=/etc/kubernetes/pki/ca,crt  --embed-certs=true --kubeconfig ./file/mykube.conf && cat ./file/mykube.conf
# 确认之前创建的 token 用户信息
cat /etc/kubernetes/auth/token.csv
# 定义User:添加身份凭据，使用静态令牌文件认证的wang用户的令牌令牌
TOKEN="1a2dab.6895748fd9e46182" 
kubectl config set-credentials wang --token="$TOKEN" --kubeconfig $HOME/file/mykube.conf
cat $HOME/file/mykube.conf
# 定义Context:为用户wang的身份凭据与kube-test集群建立映射关系
kubectl config set-context wang@myk8s --cluster=myk8s --user=wang --kubeconfig $HOME/file/mykube.conf
cat $HOME/file/mykube.conf

# 测试：将文件传到 107 主机
scp /root/file/mykube.conf 10.0.0.107:/root
# 进入 107 主机访问 kube apiserver
kubectl get pod -A --kubeconfig /root/mykube.conf
kubectl get pod -A --kubeconfig /root/mykube.conf --contest wang@myk8s
# 将文件放入默认路径下，这样每次访问就不用手动指定文件了
mkdir $HOME/.kube  && cp $HOME/mykube.conf $HOME/.kube/config
# 通过指令或者编辑文件，将对应的用户 myk8s 设为默认值
vi $HOME/.kube/config
current-contest: myk8s
# 如此这般……这般，就可以这样了！( 实现并管理 k8s 集群外访问 k8s 的用户 )
kubectl get pod -A
```

```powershell
kubectl / helm / k9s ————> kubeconfig ————> api-server
```

创建 kubeconfig 文件，只是具备了连接 k8s 集群的能力，但是后续还有授权！